<form id="input" class="input">
  <hr />
  <textarea
    name="context"
    placeholder="Enter string or context object..."
  ></textarea>
  <div class="row">
    <select name="workflow">
      {% for key in workflows %}
      <option value="{{ key }}">{{ key.capitalize() }} workflow</option>
      {% endfor %}
    </select>
    <button type="submit">Run workflow â–º</button>
  </div>
</form>
<script>
  function createDivElement(classNames = "", content = "") {
    const element = document.createElement("div");
    element.classList = classNames;
    element.textContent = content;
    return element;
  }

  document.addEventListener("DOMContentLoaded", () => {
    const form = document.getElementById("input");
    const outputDiv = document.getElementById("output");

    form.addEventListener("submit", async (event) => {
      event.preventDefault(); // Prevent the default form submission

      // Prepare form data
      const formData = new FormData(form);

      const userMessage = createDivElement("message user");
      userMessage.innerHTML = `<span class="label">Workflow input context:</span><br />`;
      userMessage.innerHTML += formData.get("context");

      const loader = createDivElement("loader", "");

      outputDiv.append(userMessage);
      outputDiv.append(loader);

      // Send POST request
      const response = await fetch("/infer/", {
        method: "POST",
        body: formData,
      });

      if (!response.ok) {
        console.error("Network response was not ok");
        return;
      }

      // Check if the browser supports ReadableStream
      if (!response.body || !response.body.getReader) {
        console.error("Streaming is not supported in this browser");
        const text = await response.text();
        outputDiv.textContent = text;
        return;
      }

      // Read and process the streaming response
      const reader = response.body.getReader();
      const decoder = new TextDecoder();

      let done = false;
      let message = null;
      let lastEventUuid = "";

      while (!done) {
        const { value, done: doneReading } = await reader.read();

        done = doneReading;

        if (done) {
          break;
        }
        // parse SSE data
        const chunk = decoder.decode(value || new Uint8Array(), {
          stream: !done,
        });
        const data = JSON.parse(chunk.replace("data: ", ""));

        // render messages
        if (data.event_type) {
          // handle intermediate event steps message
          if (lastEventUuid !== data.uuid) {
            console.log("Createing new event message ...");
            message = createDivElement();
            message.classList = "message step";
            message.innerHTML = `<span class="label">${data.label}:</span><br />`;
            outputDiv.insertBefore(message, loader);
          }
          message.innerHTML += data.result;
        } else {
          // handle final result message
          // if (lastEventUuid !== data.uuid) {
          //   console.log("Createing final result ...");
          //   message = createDivElement();
          //   message.classList = "message result";
          //   message.innerHTML = `<span class="label">Result:</span><br />`;
          //   outputDiv.insertBefore(message, loader);
          // }
          // message.innerHTML += data.result;

          loader.remove();
        }

        // store last event uuid
        lastEventUuid = data.uuid;

        // scroll to bottom on every chunk response
        outputDiv.parentElement.scrollTo(
          0,
          outputDiv.parentElement.scrollHeight
        );
      }
    });
  });
</script>
